"""This file contains SearchGraph, a base graph class built 
with a word trie for a search engine implementation.
"""
from io import FileIO # typing
from numbers import Number # typing
from typing import Any, Callable, Iterator # typing
import random
import pickle


from src.graphs.search_item import SearchItem
from src.trie.word_trie import WordTrie
from src.minimum_heap.min_heap import MinHeap
from src.utils.formatting import wordtrie_format
from src.utils.item_interest import ItemInterest


class SearchGraph:
    """An adjacency-matrix undirected graph implemented using pure Python 
    lists. Contains a built-in WordTrie for search engine purposes.
    
    This implementation of the undirected graph aims to optimize
    for memory usage.
    
    Attributes:
        graph: An adjacency matrix implemented using 2-dimensional lists.
        items: A list of SearchItems.
        words: A WordTrie containing all the SearchItem names.
        size: The active size of the adjacency matrix.
    """
    def __init__(self, init_file: str=None) -> None:
        """Constructs a SearchGraph.
        
        Args:
            init_file: A str filepath to init a SearchGraph from. This file 
            should be a file generated by SearchGraph's save_instance().
            
        Returns:
            None.
        """
        # for graphs
        self.graph: list[list[Number]] = [] # 2D matrix
        self.items: list[SearchItem] = [] # stores SearchItem data
        self.item_dict: dict[str, int] = {} # maps SearchItem names to index
        # for tags
        self.tag_dict: dict[str, int] = {} # maps tag to index
        self.tag_interest: list[ItemInterest] = [] # stores tags information
        self.tag_item: list[set[int]] = [] # maps tag to SearchItem index
        # for autocomplete
        self.words = WordTrie()
        # for sorting interests
        self.interests = MinHeap()
        # load stored data if available
        if init_file:
            self.load_instance(init_file)
        
    def __iter__(self) -> Iterator[SearchItem]:
        """Returns an iterator over all SearchItems."""
        return iter(self.items)
    
    def __contains__(self, item_name: str) -> bool:
        """Returns True if item_name is in SearchGraph, False otherwise."""
        return wordtrie_format(item_name) in self.item_dict
    
    def __get__(self, item_name: str) -> SearchItem:
        """Returns a SearchItem from a str item name."""
        return self.get_item(item_name)
    
    def __len__(self) -> int:
        """Returns the active size of the adjacency matrix."""
        return len(self.item_dict)
    
    def add_item(self, item: SearchItem, 
                 weight_func: Callable,
                 weight_thres: Number) -> None:
        """Adds a new SearchItem to the SearchGraph.
        
        Item name cannot be added if already exists.
        
        Args:
            item: A SearchItem to add into the graph.
            weight_func: A callable function to calculate the weight between 
                two SearchItems. The callable must take two SearchItems 
                as arguments and return a float weight.
            weight_thres: A numerical threshold value for edge weights.
                Weights above this threshold will be ignored.
                
        Returns:
            None.
        """
        # WordTrie format name
        wtf_name = wordtrie_format(item.get_name())
        # do nothing if name already exists
        if wtf_name in self.item_dict:
            # TODO: Add SearchGraph Exceptions
            print('[ABORTED] add_item(): '
                  f'item name "{wtf_name}" already exists.')
            return
        size = len(self.items)
        # add new item
        self.words.add_words(wtf_name)
        self.item_dict[wtf_name] = size 
        self.items.append(item)
        new_edges = []
        # add edge weights to Graph
        for i in range(size):
            weight = weight_func(item, self.items[i])
            if weight > weight_thres:
                weight = None
            new_edges.append(weight)
            self.graph[i].append(weight)
        # set itself to weight 0
        new_edges.append(0)
        self.graph.append(new_edges)
        # add tags
        self._add_tags(item)
        # sort by interest
        self.interests.add(size, -1 * item.get_interest())
        
    def _add_item(self, data: tuple[SearchItem, Callable, Number]) -> None:
        self.add_item(data[0], data[1], data[2])
        
    def get_item_by_index(self, item_index: int) -> SearchItem:
        try:
            return self.items[item_index]
        except:
            print(f'[ABORTED] get_item_by_index(): '
                  f'item index {item_index} does not exist.')
        
    def get_item(self, item_name: str) -> SearchItem:
        """Returns a SearchItem from a str item name."""
        try:
            return self.items[self.get_item_index(item_name)]
        except:
            print(f'[KEYERROR] get_item_(): '
                  f'item name {item_name} does not exist.')
            return None
        
    def get_item_index(self, item_name: str) -> int:
        """Returns a SearchItem from a str item name."""
        wtf_name = wordtrie_format(item_name)
        try:
            return self.item_dict[wtf_name]
        except:
            print(f'[KEYERROR] get_item_index(): '
                  f'item name {item_name} does not exist.')
            return None
    
    def get_edges(self, item_index: int) -> Iterator[tuple[int, Number]]:
        """A generator function to iterate over edges from a given
        source name. 
        
        Args:
            item_index: An int index of the item.
        
        Returns:
            An iterator containing a tuple of SearchItem index and edge weight.
        """
        size = len(self.items)
        if item_index >= size:
            # TODO: Add SearchGraph Exceptions
            print('[ABORTED] get_edges(): '
                f'item index "{item_index}" does not exist.')
            return
        weights = self.graph[item_index]
        for i in range(size):
            weight = weights[i]
            if i == item_index or weight is None:
                continue
            yield i, weight

    def result_matches(self, query: str, limit: int=10) -> list:
        """Takes in a str query and returns a list of possible
        words matching the query substring.
        
        Args:
            query: A str query.
            limit: An (optional) int for max word suggestions.
                Defaults to 10 suggestions.
            
        Returns:
            A list of complete words that matches the given query.    
        """
        return self.words.word_suggestions(query, limit)
    
    def add_click(self, item_name: str) -> None:
        """Adds click counts for the corresponding item name,
        can be SearchItem or a str tag."""
        wtf_name = wordtrie_format(item_name)
        item_index = self.item_dict[wtf_name]
        item = self.items[item_index]
        item.add_click()
        self.interests.change_priority(item_index, -1 * item.get_interest())
    
    def add_appearance(self, item_index: int) -> None:
        """Adds appearance counts for the corresponding 
        SearchItem and its tags given by an index."""
        item = self.items[item_index]
        # update tag appearance count
        for tag in item.get_tags():
            tag_index = self.tag_dict[wordtrie_format(tag)]
            self.tag_interest[tag_index].add_appear()
        # update appearance count
        item.add_appear()
        # update interest
        self.interests.change_priority(item_index, -1 * item.get_interest())
        
    def update_all_interests(self) -> None:
        """Updates the interest for all items in SearchGraph."""
        for i in range(len(self)):
            item = self.items[i]
            interest = item.get_interest()
            # update if item exists
            if i in self.interests:
                self.interests.change_priority(i, -1 * interest)
            else:
                self.interests.add(i, -1 * interest)

    def remove(self, item_name: str) -> None:
        """Removes a given item from the SearchGraph."""
        # if item_name in self.items:
        #     self.graph.remove_node(item_name)
        #     self.items.pop(item_name)
        #     self.words.remove_words(item_name)
        NotImplemented
    
    def random_item(self) -> SearchItem:
        """Returns a random item from the graph."""
        return random.choice(self.items)

    def _add_tags(self, item: SearchItem) -> None:
        """Adds to internally-stored tags data."""
        wtf_name = wordtrie_format(item.get_name())
        item_index = self.item_dict[wtf_name]
        for tag in item.get_tags():
            tag = wordtrie_format(tag)
            # instantiate data for new tag
            if tag not in self.tag_dict:
                self.words.add_words(tag)
                # print(self.tag_item, self.tag_interest)
                # map tag index
                self.tag_dict[tag] = len(self.tag_interest)
                # store tag data
                self.tag_item.append(set())
                self.tag_interest.append(ItemInterest())
            # get tag index
            tag_index = self.tag_dict[tag]
            # map item index to tag
            self.tag_item[tag_index].add(item_index)
            
    def save_instance(self, file_path: str) -> FileIO:
        """Saves the current SearchGraph data as
        a pkl file from a str file path."""
        print('[STATUS] save_instance(): Saving SearchGraph data.')
        attrs = vars(self)
        with open(file_path, 'wb') as f:
            pickle.dump(attrs, f)
        print(f'[STATUS] save_instance(): '
              f'Saved SearchGraph data in {file_path}.')
            
    def load_instance(self, file_path: str) -> None:
        """Reads from a file generated by save_graph() to
        load the data of a previous SearchGraph."""
        try:
            print(f'[STATUS] load_instance(): '
                  f'Loading SearchGraph data from {file_path}.')
            with open(file_path, 'rb') as f:
                attrs: dict[str, Any] = pickle.load(f)
            for name, attr in attrs.items():
                setattr(self, name, attr)
        except:
            print(f'[ERROR] load_instance(): '
                  f'unable to read {file_path}.')